<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Front End Start Guid--HTML]]></title>
    <url>%2F2020%2F03%2F04%2Ffront-end%2Fstart-guid-html%2F</url>
    <content type="text"><![CDATA[前端的学习从HTML（看清楚是超文本标记语言 Hyper Text Markup Language, 面试官问你的时候千万不要说成 How To Make Love）开始，三剑客的其它两个（CSS和JavaScript）都是以HTML为载体。学习HTML首先要知道HTML是干什么的，MDN上面有很直白的解释，我相信聪明的你很容易理解这份文档里面的内容。仔细的阅读并彻底的理解HTML的定义将对你之后的学习有很大的好处，你之后HTML方面的学习也是围绕的这份看起来简单的定义展开。 在理解定义之后，我推荐你把所有的HTML标签都尝试着自己敲一遍，然后在浏览器里面看效果，及时且可见的编程成果很容易使你获得成就感，这会使你保持学习的冲劲/动力。我并不推荐你一上来就把所有的HTML标签背下来，这样做对你的学习并没有很大的帮助，但是浏览一遍这些标签各自的定义是有必要的，这有助于你理解他们各自存在的意义，我推荐的做法是在你把所有的HTML标签尝试一遍之后，试着把他们组合着进行使用，自己创造一些看起来“奇形怪状”的东西。 在完成上面两个步骤之后，请不要急于学习CSS或者JavaScript，我推荐你花时间去理解HTML 中的语义化标签并学习如何正确的使用它们，我觉得这一点在工作中尤为重要，你不会因为一个页面写了两个h1标签而被骂（因为你根本就不会这样做），学习并熟练运用HTML语义化会使你写的页面看起来更加的“专业”。 可能你在将来的工作中用到原生HTML的场景可能并不多，甚至用不到（当前前端组件式框架的的流行），但我还是建议你好好的去学习HTML，万变不离其宗，它框架即使再多，也是在原生的基础上做的封装。HTML内容看起来不多，但它却是整个前端的基石，，希望你在这个阶段的学习过程中多做练习，多思考，这样才能为以后的学习打好基础。 Tips 关于代码编辑器，我比较推荐vscode，这是微软发布的一个免费的代码编辑器，上面有大量的插件供你使用，在当前这个阶段，我再推荐一个比较实用的插件：Open In Browser，这个插件可以让你很容易的在浏览器里面直接打开当前所编辑的HTML文档，只需要按键盘上的Alt + B就可以。]]></content>
      <tags>
        <tag>front end</tag>
        <tag>前端</tag>
        <tag>start guid</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS系列一：起源、特点以及应用场景]]></title>
    <url>%2F2020%2F02%2F13%2Fnodejs%2Fs1-start%2F</url>
    <content type="text"><![CDATA[起源NodeJS是一个基于Chrome V8引擎的JavaScript运行环境，由Ryan Dahl创造的（你知道的，就是后来又搞了deno大家在那个项目issues里面吐槽学不动-了），可以让我们的JavaScript代码在服务器端运行，RY的初衷是写一个基于事件驱动以及非阻塞I/O的的web服务器，所以最开始，RY也称NodeJS为web.js，但后来项目的发展显然超出了他的预期，这也归功于JavaScript的门槛低，简单易入门。大佬曾经评估过其它语言：C的开发成本较高而且对于一般的开发来说是比较难懂的；大佬想用Haskell，所以就放弃了…很庆幸大佬选中了JavaScript，给了我们前端er轻松进入后端的机会，当然，这也造就了一大堆自称“全栈开发者”同行。 特点主要特点一就是单线程，这也是JavaScript的一大特点，NodeJS保持了浏览器中JavaScript的这个特点，好处就是不用在意线程之间的状态同步，也没有死锁等问题，不好的地方也就是单线程的弱项：无法利用多核CPU；错误会引起应用退出；大量计算占用CPU会导致无法继续调用异步I/O 第二大特点就是事件驱动：NodeJS会把所有的异步操作使用事件机制来解决，说到这个让我想起了回调地狱，不过现在好多了，有了Promise和async/await，就是try/catch总让我觉得不那么优雅 第三个特点是非阻塞I/O：也就是在程序读取文件的时候不会阻塞代码的继续执行 另一个特点就是很容易的让同一个开发者同时具备前端和后端的开发能力，这其中的好处自然也不用我多说了，纵观上一个十年，JavaScript的发展突飞猛进，不论是在前端，还是在服务器端，都是大放异彩，各种优秀的前后端项目也是层出不穷，JavaScript程序员数量也是翻倍的增长，不过还是有巨大的人才缺口在等着后来者去填补 One more thing：总会被忽略的轻量级和跨平台特点以及简单的环境搭建都是可以大大的提升程序员编程幸福指数的 应用场景 在线聊天：socket.io是个好东西~ restful API：把复杂且非敏感的逻辑运算交给前端完成，后端负责准备数据，这样就可以利用NodeJS的高并发这个特点，构建restful API，既有高并发，又得到了高性能 其实我还想说一个构建跨平台桌面应用程序的东西：Electron]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端数据交互之数据压缩]]></title>
    <url>%2F2020%2F01%2F19%2Fdevelop%2Fexcel-transfer-data%2F</url>
    <content type="text"><![CDATA[最近做了一个项目的性能优化，觉得这种优化方式比较少见，所以记录一下事情是这样的：我们项目上某个页面需要一次性能够显示8年时间内所有的销售数据，另外前端还是用了葡萄城公司的wijmo产品做了透视表，以便财务人员查看及分析数据。我们8年的销售数据大概有14万条，通过普通的json传输的总大小为63M，传输速度特别慢，而且最重要的是常常会导致后端服务器挂掉或者500，因此我们顺序的做了以下的优化 第一次优化：更改数据的传输格式原始的数据格式为是这样的： 12345[ &#123;k1: v1, k2: v2&#125;, &#123;k1: v11, k2: v12&#125;, &#123;k1: v21, k2: v22&#125;,] 通过观察我们发现在传输的数据中大量的key是重复的，所以我们第一次优化是把数据改为以下类似于表格的格式： 123456[ [k1, k2], [v1, v2], [v11, v12], [v21, v22]] 这次优化下来，传输过程中的数据量变为了36M左右，还是很大的，在网络一般的情况下耗时还是比较长，本地测试是正常状态，但是到了线上，还是会出错，而且是跟没优化前一样，直接会导致服务器挂掉。 第二次优化：分段请求通过对比发现单次请求耗时较长，我们又试着利用请求并发的特性（chrome下是6个），在第一次优化的基础上进行了第二次优化，如图所示 前端 &lt;&gt; 后端 我需要请求几次？ –&gt; 我给你算算 好的，我这就开始请求十次数据 &lt;– 一次给你5000条数据，需要你请求十次 十次请求并发执行 –&gt; 分段返回数据 这次优化结果能好一点，不论是生产环境还是在本地测试，都没有出现服务器挂掉的情况，但是请求时间貌似没有什么变化，耗时还是比较严重。 第三次优化：祭出string table大法通过查找资料，我们发现string table这种数据结构可以对数据进行大幅的压缩，恰巧Excel的存储就用的是这种数据结构，又恰巧我们的前后端都使用了类Excel的产品（前端SpreadJS，后端Spread.NET），我们就做了一次尝试，把数据通过Spread.NET装进表格中，然后再把表格以blob的形式传递给前端，前端的SpreadJS接收到数据之后就进行了解析以及提取，最后塞给wijmo的透视表，通过测试，数据传输量又一次有了明显的下降，变成了21M左右，传输时间短了很多，但是在后端给Excel填数据的时候，花费了好几秒，后来把Spread.NET进行了升级，最终这个时间也压缩到2秒之内了。 你知道，人总是不满足的，我们在这里尝到了甜头之后，又去仔细的查阅了一遍Spread.NET的文档，发现在导出Excel时有一个紧凑模式（isCompactMod），又尝试性的添加了一个导出的flag，这次数据传输量直接变成了8.5M左右，传输速度又是一次巨幅提升。 总结我还在想完全不使用Excel，单独的自己弄两个函数来实现string table的读和写操作。不过这次来说，也算是对Excel有了新的认识，现在才知道xlsx文件后缀名改为.rar之后提取出来就是一堆的xml，刚看到这个还是比较惊讶的，真是学海无涯~ 参考： String Table 参考一 String Table 参考二]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>数据压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Github Action]]></title>
    <url>%2F2020%2F01%2F14%2Fcicd%2Fghaction%2F</url>
    <content type="text"><![CDATA[Github Action发布到现在（2020.1.14）已经一年多了，这一年多，已经有了将近2000个 Action，包括测试，持续集成，代码质量检查等，我今天也试着用了一下，总的使用体验还是蛮好的，如果之前使用过类似于drone这类的pipeline工具的话，会让你觉得基本是无缝切换。下面就简单分享下我的使用过程。 创建仓库这个很简单，我直接以我的博客为例，本博客是使用hexo进行搭建的，所以很简单，本地装好hexo cli后用命令行初始化一个blog仓库，然后推到github的线上仓库中就可以了。 添加Action配置文件这一步新手的话推荐在线上完成，点击进入仓库下的Action页面，然后点击新建一个，当然你可以使用示例的配置，我博客下面的配置是这样的： 123456789101112131415161718192021222324name: Deployon: [push]jobs: build: runs-on: [ubuntu-latest] steps: - uses: actions/checkout@v1 - uses: actions/setup-node@v1 with: node-version: "12.x" - name: Build run: | npm install npm install -g hexo-cli hexo generate - uses: appleboy/scp-action@master with: host: enginebeck.com username: $&#123;&#123;secrets.username&#125;&#125; password: $&#123;&#123;secrets.password&#125;&#125; port: 22 source: "./public/*" target: "/home/beck/blog/" 编辑完成之后点击保存，项目根目录下会多一个.github的文件夹（如果之前没有的话），.github文件夹下面会有一个workflows文件夹，我们的配文件就保存在这个文件夹里，其实可以猜到，我们可以给项目中添加多个这种配置文件，比如我这个项目就有两个配置文件，一个配置文件配置的是将博客部署刀自己的vm上，另一个是部署到github pages上，每次推完代码两个同时且独立的运行，互不影响。 上面这个配置文件很好理解，首先我们有一个Action名称[name]，接下来当仓库中有代码push时会触发这个Action，jobs下定义了具体的任务步骤，首先定义接下来的任务运行在什么操作系统上，后面使用了两个官方的action进行拉取代码以及设置基础的node环境，紧接着就是我们熟悉的安装node包和编译博客，最后使用了一个scp action把编译好的静态网文件发送到我的vm上，任务到此就结束了 看起来挺简单的，但是在实际的项目中总会有一些不一样的需求，还是需要多动手去实践，我也是用的比较浅，目前暂时还没有遇到什么问题。 总结这个东西虽然说是新发布的，但我感觉其实是gihtub把travis ci或者drone这类东西自己做了一份，而且对于私有项目还可以让我们免费的使用github的服务器资源，可以说是非常的良心了，另外从商业的角度来看，这也是微软收购github之后让github和自己原有的云服务深度融合的一个开始，20年上半年github官方的移动APP也会出来，期待有了不差钱爸爸的github给我们广大的开发者带来更多好用实用的功能。]]></content>
      <categories>
        <category>cicd</category>
      </categories>
      <tags>
        <tag>cicd</tag>
        <tag>github action</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年终总结]]></title>
    <url>%2F2020%2F01%2F14%2Fsummarize%2F2019%2F</url>
    <content type="text"><![CDATA[回首2019年，这一年不论是生活上，还是技术上都有了很大的改变与提升，有很多东西值得回头来细细品味，本篇说说技术方面的。 上半年年初，在做着一个 .NET Core 的小项目，是维护工作，之前是没有在工作中真实的接触过.NET平台下的开发，开发过程中凭着自己大学时学的那点可怜的基础以及在 NodeJS 的开发经验，还愣是把这个项目算是平稳的做了下来，虽说之前也是一直做偏前端的工作，但是这个项目做下来，让我感觉到其实在语言层面上大家的差别并不大，而在编程思想上 NodeJS 和 .NET Core 还是有比较大的不同。 等到 3 月中旬左右，又开始了一个技术调研工作，目的是尝试使用 FileMaker 做一个工作流之类的项目，这也是让我今年感觉到最为痛苦的一段时间，前后大概有一个月的时间，到一半的时候其实已经感觉到 FileMaker 并不是我们想要的解决方案，但是又不得不硬着头皮继续搞下去，最终出了一个结果，我们并不能使用这个东西来完成我们想要的功能 期间调查过前端离线应用的功能，对比了当前的几个前端离线应用的库，最终发现 workBox 这个库还是挺不错的，谷歌出品，代码提交频率也挺高， github 的星也挺高，这之后又对之前的一个powerBI项目做了维护工作，主要是让 PowerBI 适配 19 年的数据， PowerBI 给我的使用感受就是只要不太追求美观，功能上做的还是比较好的，这也是微软近几年新出的一个产品，说到这块，今年也大量的使用了微软的各种产品，不得不说微软的产品线是真的全，从代码管理到应用部署，从任务管理到团队实时的消息沟通，各方面都有，而且做的还都挺不错的，虽然我不是微软的粉丝，但还是由衷的赞叹他们的工程师，真棒~ 这段时间之后我又做了一个小项目，使用葡萄城公司出品的类 PowerBI 的一个产品 – Wyn 把 PowerBI 上的数据展示用这个工具又做了一遍，这是一个新产品，虽然部分地方细节做的不足，但还是一个不错的选择，基于 Web 的炫酷的图标切换，配套的使用 socket.io + koa 做了一个小型的 node 服务，主要功能是进行 SQL Server 数据库之间的数据同步，中间再对数据做一些处理，刚好这个机会，自己也从申请服务器开始到部署应用从头到尾的走了一遍整个流程，之前在自己的服务器上只是练习，并没有在生产环境搞过这些东西。 上半年也在持续不断的学习 golang，看过很多别人写的代码，自己也写了一个小项目练了练手，前两年也断断续续的学习过 golang，不过由于一些原因没有坚持下来，主要是因为 golang 的包管理，跟 node 比起来实在是差太多，不过随着18年 go11 的发布这方面有了很大的改善，另外也是因为自己知道了像 goproxy.io , goproxy.cn 这样的代理网站，下载包实在是方便了太多，正好有段时间哔哩哔哩的一部分后端源码泄漏，有幸下载下来，自己也“观摩”了一段时间，总得来说，今年下来，对于 golang 算是入门了，前路漫漫呀。 公司也在6月搬了新办公室，感觉挺棒的，虽然比不上之前温馨，但是给人一种更正式的感觉。 下半年下半年做了很多重构的事情，一开始就使用 golang 把自己年初维护的那个 .NET 项目做了重构，前端用了 reactjs，后端 golang，做起来还算顺利，中间又顺手把前端改成了 typescript，算是一大进步吧，这也算是我司第一个 ts 的项目。这个项目性能方面至今仍然不好，最近这两天还在做一些优化。项目的部署也是用自建的 drone 服务做了自动化，drone这个东西很方便，也很实用，尤其是可以自建服务（免费）这一点，不过随着我这个项目前端代码以及第三方的逐渐增大，由于服务器性能不足，导致了我的 drone 不能编译前端项目，一跑任务服务器就挂起，最后没办法，本地编译好后只使用 drone 上传到服务器上。 之后又用 PowerBI 把之前维护的 PowerBI 那个项目重做了一遍，数据源变了，功能上也有了比较大的调整，这次使用的 PowerBI 功能还是挺多的，不过很多地方都是类似于 Excel 的表达式，或者是 SQL 的查询语句，是真的方便。 同期也在公司内部组织着小伙伴们进行了技术学习，reactjs 基础知识，typescript 基础知识，还有一些程序开发方面的常识，总体来说大家反馈还是比较好，虽然中途罚过部分人的钱，前几天开年终总结会议的时候大家一致认为这点做的非常好，希望继续保持下去。 到年末，花了又做了一个小项目，还是使用自己之前 golang 和 reactjs 项目的架子，比较快的就做完了，之后又对另一个 .NET 项目做了维护工作，跟年初那个项目一样，同一个人开发，几乎相同的功能，完全相同的技术，不过这次是我跟我另一个同事一起。 这一整年下来，其实对我感触比较深的是前几天见了一个投资人，把我之前做的一个项目给他做了介绍，问题确实是比较犀利，也能明显感觉到自己的开发思维太重，我们这些程序员呀，还是太单纯，这让我想起来最近看到的一句话：code is cheap, give me money. 欢声笑语，一年一年又一年，希望2020公司有好的发展，自己也有足够多的成长与进步，给这个十年起个好头。]]></content>
      <categories>
        <category>summarize</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4 年小结(2015~2019)]]></title>
    <url>%2F2019%2F12%2F19%2Fsummarize%2F2015to2019%2F</url>
    <content type="text"><![CDATA[转眼之间，算上实习在内已经工作4年半了，这几年，接触到了很多东西，今晚突然心热，就有了这篇总结自己这几年技术生涯的文章 时间回到2015年，那时候还在上大学，在学c#应用程序，也就是那个时候，第一次接触到了前端，当时使用vs2015创建了一个.NET MVC程序，发现运行起来的demo页面很漂亮（当然我当时还没有做过前端），怎么说呢，感觉很神奇，看了看示例程序的代码，发现原来是用了Bootstrap，当时也看网上别人用css撸的大白，把我看的一愣一愣的，从那时起，就入了前端这个坑。 那年的暑假期间，自学了一个多月，记得当时是跟着极客学院上的无闻学，后来又买了本书《HTML5权威指南》，就那本特别厚的图灵出的前端书，学完之后自己模仿着做了一个网页版的flappy bird。然后来学校报名，之后就开始找工作，本来上大学的时候Java学的还挺不错的，奈何出去找工作，一找一个培训班，最后还找了个培训班请我当老师（可想而知那些培训班质量有多差），最后一气之下想着去试着找找前端工作，面试的第一家《XX科技》就通过了，然后就去这家公司上了班，在这家公司呆了4个月左右，平时工作还是挺饱满的，也就是这段时间，把我的原生js和jq以及bs3的能力练起来了，当然也学会了版本控制工具svn的基础使用方法，记得当时用蓝灯还是免费无限量的，还有个叫自由门的软件（你懂得）。也不知道那家公司现在怎么样了，不过前几天听说都离职了，可能很早就解散了吧。 15年底，离开了第一家公司，跳到了另一个公司，在这个公司呆了1周，感觉技术氛围一般，主要是前端我一个人撑着呀，没人带我，就又跳槽了，来到了现在我呆了快四年的瑞木，这里很吸引我的一个地方就是虽然也是个小公司，但是技术氛围很浓厚。 16年，以实习生的身份呆了半年后转正，刚开始，做了后端的对node程序的API的自动化测试，后来又开始接触了node，之后又是前端的angularjs，最后全面学习Meanjs，其实说来也巧，当时公司刚好把项目结构从Mean.io往MeanJS转，我有幸参与其中，也学习到了很多知识，前端angular，html，css，less，后端的node，Expressjs，async，mongoose，MongoDB，还有代码管理工具git的使用，更是培养了我长泡github的习惯。其实这一年折腾的也是比较厉害的，光系统重装了不下10次，虚拟机已经忘了多少次了，也非常感谢当时的一位大佬教我用ubuntu，算是带我入了门吧，用过nodejs 4.x的人应该都知道，自动化测试需要下载的phantomjs的那个包呀，实在是难下载，我是搜了很久才找到我另一篇文章中介绍的安装设置。 来公司不久后还做过一个wordpress项目，用XAMPP在本地起项目，好像之后我自己还在阿里云上买了一个wordpress的服务器，唉，真是坑呀，当时其实想买一个 CES 服务器的，由于不熟悉，第一次买服务器，谨慎又谨慎，最后还是买错了，不过还好是只买了一年的。 那一年的后半年，正式开始了一个项目，印象很深的是那个ELO算法，在这个项目中后半年我基本都在负责前端的开发，不过也接触到一些后端，那段时间还对mailgun做了比较深入的了解，还有一个邮件订阅管理的工具/系统，好象是叫comma，还有一个就是亚马逊的MTurk，真是棒呀。还有oauth2，刷token这些，也是这一年，了解了grunt，我记得应该是夏天的时候，还跟着建哥去WDshare做了一次分享（当然是建哥在台上讲，我在台下听） 进入17年，我项目的后端的老大哥逐渐转为part time，后又彻底离职，我也开始接触我们项目的后端，直到两三个月后完全host整个项目，这一年，搞过太多事情了，把后端图片处理基于image magic的gm换成sharp（我记得当时sharp只有不到4k的start，现在…还是眼光好呀），用户系统重构，折腾Azure Stack，线上MongoDB数据备份及恢复，也是这一年会用了ssh远程线上服务器…也带着别人做项目，跟美国客户邮件交流，review别人代码，新功能评估，制定小组工作计划，还有，好像接触了一点golang，不过当时golang的包管理实在是弄得人头疼，也就浅尝辄止了，还有facebook登陆，firebase消息推送，Google的站长工具和analytics的使用，RN App的发布（我只会发布不会写呀，虽然感觉不难但是从没尝试过，到现在都是…），记得那一年还用过惠普的Storm Runner做过压力测试（我怀疑这个东西我用的不对），还有用node-canvas把d3做的chart渲染成图片。年中的时候我们又用了gulp，好像是同时吧，也把sass用了起来，node-sass那个难装呀，跟当时处理图片元数据的exiv2一样，也是这一年，给网站去做SEO，专门给各种爬虫写了一些页面，供他们使用，Google和FB的各种meta标签也是用了一大堆。 18年又有了很多新的挑战，移交了之前的项目，开始了一个新的项目，第一次项目中需要使用socket.io，又屁颠屁颠的去学习怎么用socket.io，之后又要搭配着使用Web rtc，记得当时还顺带了解了下obs studio，当然我是不会用的，老大年初的时候还研究过webvr，用HTC VIVE调试了很久，也是第一次，系统中有六七个角色需要管理，下半年又开始了一些原生开发相关的工作，深入学习spreadjs，由此也对Excel有了比较深入的了解。之后又需要给spreadjs做个小插件又深入的学习了SVG，SVG这个学习的的确是很深，看了很多W3C上的文档，末了工作需要又去维护.NET core程序，这一年还开始负责了公司的面试，面试了一整年下来也就进来了两个人，也是年底左右开始正式的去学习GO，因为总觉得自己是在做前端，也开始用了SQLServer和MySQL。也是在这后半年，好好学习了react.js（之前都是用ng1.x的） 19年也是折腾不止的一年，年初继续搞.netcore程序的维护，后来运行平稳后折腾了1个月的filemaker，紧接着对一个PowerBI项目做了维护，后又去使用wyn做了个项目，做好后开始用golang写了个后端，react写了个前端，其实最开始是用koa起了一个前后未分离的项目，后来心一横，方案就改了，reac前端还是感觉不香，项目开始半个月后又把js换成了typescript（你看，我多么善变）。后来完整的做了一个powerbi项目，确实使用体验还是比较好的。再之后的一个小项目中也第一次使用到了听了好久的SQLite。再到最近这两天实现大牛告诉我们为了减小数据传输量而使用Excel流来传输数据，带着团队一起学react，ts，自己也算是深入的学习了golang，体会到它并发的方便，优雅，还有在golang中使用jwt，casbin，gin等插件库… 上半年，还为了写go程序方便，折腾发布了一个vscode的插件，但是后来用goland是真香呀，这东西最开始就用过，刚发布那会叫gogland，后来改名了变成了goland。 还是19年，买了自己的服务器，买了好多个域名，逐一进行了备案。折腾nginx，使用Hexo在自己的服务器上部署这个博客，用drone做持续发布，使用docker部署了一些MySQL，MongoDB这类的服务，也尝试了部署了很多的开源项目，比如gitea，HFish，drone等，还霍霍着团队的人都买了个域名，像模像样的弄了个个人博客。 19即将过去，应该就到这里了，这个流水账也还算是详细。 回看这几年，一路过来全是挑战，当然也是离不开Ken、Tom、howard、Andy、Irene、Mia、Helen、Ada、Sega、Jacy等人的大力帮助与支持，非常荣幸能与这些人一路同行，劈荆斩棘。 2020，up]]></content>
      <categories>
        <category>summarize</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Docker]]></title>
    <url>%2F2019%2F11%2F18%2Fdocker%2Fdocker%2F</url>
    <content type="text"><![CDATA[什么是DockerDocker 是DotCloud于2013年开源的内部项目，docker是用go语言编写的一个开源的应用容器引擎 有哪些竞品？ CoreOS OpenVZ RedHat project Atom LXC(Linux Container) Present situation of docker Docker创始人已经从Docker公司离职 Docker 宣布拥抱k8s 公司曾经估值10亿刀，现在却在感谢大家在公司财务面临巨大压力下仍然坚守岗位 Docker 将 Docker Enterprise 卖给​ Mirantis：随后融资 3500 万美元，迎来新CEO 以为这些就完了吗，我们来看看其它的一些数据：github搜索一下docker，仅仅star 5k以上的相关的仓库数量就达到68个，总数量更是多达432k， Docker核心概念Docker的核心就是：镜像、容器和仓库 在我的理解上，一直把Docker镜像理解为我们编译后的一个APP，可以直接在特定的环境中运行，而在这个特定环境中运行起来的APP，就是上面所提到的容器，当然我们会有很多不同的APP会被创建出来，这些APP会被集中在应用分发中心供大家挑选使用，这个分发中心也就是我们这里的Docker仓库的概念了 使用场景 持续集成/发布（CI/CD）：有流行的drone，jenkins等工具 应用隔离：因为Docker“轻”的这个特点，我们可以把每个应用就部署到自己单独的Docker容器中，这样一来，各个应用之间相互隔离，环境也各不影响，Nginx一个Docker容器，MySQL一个Docker容器，API服务一个容器…你看，多方便 自动化打包 快速部署 自动化测试 牛刀小试安装Docker基础环境一般自己试着玩或者学习使用Docker-CE就足够了，顾名思义，也就是Docker的社区版，类似于宇宙最强IDE Visual Studio的社区版一样，安装方式Docker官方文档中给的比较详细，本文也就不再班门弄斧了 Dockerfile的编写下面这个示例是一个应用的示例，原始仓库在这里，这里第一句就是基础镜像，可以看到我们使用的是ubuntu 18.10这个基础的操作系统，然后把当前文件夹下的apigo文件，也就是编译好的文件复制到了对应的ubuntu系统中，再之后也把配置文件也复制了进去（这里说一下，如果有两个参数的命令，第一个是本机，第二个参数是对应的镜像），接着暴露8002端口后直接运行我们的应用 12345FROM ubuntu:18.10COPY ./apigo ./apigoCOPY ./config/config.default.toml ./config/config.tomlEXPOSE 8002CMD ["./apigo"] 镜像的构建构建镜像时在命令行中进到我们Dockerfile所在的文件夹下（当然也可以特别指定Dockerfile的路径），然后使用如下命令进行构建注意后面有个.，参数中的-t就是给我们的镜像起名字的作用，官方文档中有更多关于其它编译参数的说明 1docker build -t &lt;name&gt;[:&lt;tag&gt;] . 运行镜像我们大多数人运行的第一个docker容器都是docker hello word，在安装好Docker基础环境之后，官方文档中让我们测试是否正确安装的命令也是在教我们运行第一个Docker容器 – sudo docker run hello-world，除此之外，运行时还可以进行加一些其它的参数来进行，如-v是关联宿主机的fs，–rm是stop后立即删除，–name是给container起个别名，毕竟每次要操作container的时候使用输入id还是太麻烦了，这样的参数还有很多，官方文档里有详细的解释说明 其它 容器编排 Docker Swarm k8s Docker容器间通信 link connect DNS Server join 参考 CoreOS VS Docker容器大战，之容器引擎 Docker系列学习文章 - 什么是容器技术？（一） 容器，你还只用Docker吗？ Docker 文档 Is Docker in Trouble?]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些工具网站]]></title>
    <url>%2F2019%2F09%2F25%2Fother%2Ftoolsites-md%2F</url>
    <content type="text"><![CDATA[一些好用的程序/文件/插件 IDE主题 记录你的编程时间 一个密码记录工具 adblock 这个估计很多人都知道 启动盘制作工具 Rufs 启动盘制作工具 Etcher 百度网盘不限速下载器 BND 一个比迅雷更好用的下载器 微软官方的office模版 免费的矢量图/图标下载网站 不要太好用的zsh配置 阿里巴巴矢量图标库 win merge: windows下开源且免费的对比及merge工具 一些国内的镜像网站 淘宝 NPM 镜像 网易开源镜像站 清华大学开源软件镜像站 谷歌学术镜像（不能解释太多了） 搜狐开源镜像站 阿里云开源镜像站 中国科学技术大学开源软件镜像 其它 苹果产品购买指导 http状态码 一个好用且纯净的电脑防护软件 ES2015在nodejs中的支持情况 公司开源导航 我帮你百度一下 快递大件发物流更便宜哦]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>工具网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些生理学的基础知识]]></title>
    <url>%2F2019%2F09%2F23%2Fmedicine%2Fshenglixue-basic%2F</url>
    <content type="text"><![CDATA[T 淋巴细胞的功能不包括吞噬功能 关于免疫球蛋白的表达，正确的是 1g 可分为分泌型和膜型 腮腺导管开口于上颌第二磨牙颊粘膜，颌下腺开口舌系带舌下阜，舌下腺开口舌下阜(颌下腺导管))和舌下壁 刺激胰岛素分泌最主要的因素是血糖浓度升高 肺循环起于右心室 葡萄糖进入细胞的方式包括易化扩散、主动转运 在行红外线治疗的时候，辐射器与治疗部位的垂直的距离为 30 一 60cm 有关男性尿道正确的是分为前列腺部、膜部和海绵体部 真菌不能引起的疾病是潜伏感染 小说《红楼梦》中的林黛玉，动作缓慢稳定、做事细致入微、敏感多疑，孤独多虑，情感体验深刻且持久。根据希波克拉底的体液学说，其体内占优势的体液是黑胆汁 运动性语言中枢位于额下回后部 关于长期制动对关节周围韧带可能造成的影响叙述正确的是关节囊壁的滑膜增生 偏瘫、截瘫或残肢仅保留少许功能在肢体功能障碍分级中属于 II 级 一个心动周期中主动脉中压力最高值与最低值差为脉压 切断支配小肠的迷走神经，可以导致小肠的紧张性和蠕动几乎不受影响 现代生理学观点，兴奋性是细胞在受刺激时产生动作电位的能力 大脑皮质躯体感觉 I 区位于中央后回（3-1-2 区） 安静时细胞膜内外的电位差静息电位 引起动作电位去极化的临界膜电位是阈电位康复医学网校整理 一声霹雳、一道闪电，这些极强的刺激能立刻引起无意注意 成年男性的体液占该男性体重的百分比约是 60% 关于 HCOJ 在近端小管重吸收的描述，正确的是与小管分泌 I-I 十相偶联 促进钾进入细胞内使血钾下降的激素是肾上镍素 产生静息电位和动作电位的跨膜离子移动过程属于通道中介的易化扩散 紫外线照射时剂量和距离之间的关系为剂量和距离平方呈反比 意志是通过影响认知过程和情绪过程对人的健康产生影响 知觉的恒常性是指在知觉过程中对事物知觉的恒定或不变性 组成门静脉的静脉有胃左静脉 突触后电位发生空问总和的结构基础为神经元问所构成的是聚合式联系 巩膜不是眼的附属器官 中耳的组成为鼓室、咽鼓管、乳突小房 内脏疾病常引起体表某部位发生疼痛或痛觉过敏，涉痛的皮肤部位是受同一脊髓节段的后根神经支配 关于 HCO 子重吸收的叙述，正确的是若滤过的 FICO）量超过分泌的 H 量，HC0）就不能全部被重吸收 脑干的组成中无间脑 肱骨体中部骨折容易损伤的神经是桡神经 能外展肩关节冈上肌 能内收、旋内和后伸肩关节背阔肌 心脏的正常起搏点是窦房结 听觉感受器位于螺旋器 既能跖屈又能使足内翻的肌是胫骨后肌 生命中枢位于脊髓、延髓 摄食中枢和饱中枢位于延髓 注入静脉角的是淋巴导管 超短波的电磁振荡频率范围为 30 一 300MHz 正常人潮气量平均约为 500ml 激素的作用方式有近距分泌 康复是指应用综合措施，旨在减轻残疾和残障状况，并使他们有可能不受歧视地成为社会的整体 想像的基本材料是表象 传导电流的定义是电荷在导体中流动传导所产生的电流 睾丸分泌睾酮 与右主支气管相比，左主支气管细而长 抑制性突触后电位产生时，突触后膜局部的变化是超极化 个细胞的动作电位波形不能完全融合的原因是不应期 局部兴奋的产生是由于阈下强度的外向电流直接造成的电压降和膜自身轻度去极化叠加的结果 血管系统的失健现象，表现为安静状态下心率增快，每搏量减少，运动时以加快心率来提高心输出量 红骨髓是造血器官，具有造血功能 患者，男性，65 岁，左侧脑出血伴右侧肢体功能障碍，言语不能，大小便失禁，未进行正规康复治疗，昨日家人在帮其清理大便时发现骸尾部破溃，于是送当地医院治疗，经医生检查发现：骨氏．尾部皮肤破溃，呈紫红色，局部有液体渗出，诊断为压疮，患者产生压疮的原因不包括局部血液循环障碍 在胰液中凝乳作用较强的酶是糜蛋自酶 哺乳动物神经细胞间信息传递主要靠化学突触 音频电疗法的频率范围为 1000 一 5000Hz 黄韧带连于两个相邻的椎弓板之间 属于淋巴组织的是淋巴小结 汇合成9条淋巴导管的是淋巴干 计数椎骨棘突的标志是隆椎棘突 感受旋转运动的刺激是椭圆囊斑 感受直线变速运动的刺激是乳突 肌梭的传入神经纤维是Ⅰb类 腱器官的传入神经纤维属于Aα类 胸骨角平对第2肋软骨 兴奋性与抑制性突触后电位相同点是是递质使后膜对某些离子通透性改变的结果 糖原合成的主要生理学意义是储备能量 影响正常舒张压的主要因素是阻力血管的口径 既是机体获能的主要方式，又是糖、脂肪和蛋自质三种物质在体内彻底氧化的共同代谢途径及它们之间互变的联结机构的是三羧酸循环 良好训练者安静时率减慢，每搏输出量增大 生理情况下影响收缩压的主要因素是搏出量的变化 心输出量是指心率与搏出量的乘积 2 个月大男婴，不会拥抱、吸吮、觅食，可能是原始反射所致 二尖瓣附着于左房室口周围 肺动脉瓣位于右心室流出道口周围 根据应答肌肉的名称与性质分类的反射是跟腱反射 胃肠平滑肌动作电位产生的主要离子基础是 Ca2＋内流 脊髓灰质的侧角是交感中枢 机体保钠的主要激素是醛固酮 细胞受刺激而兴奋时，膜内电位负值减少称为去极化 大多数可兴奋细胞接受刺激发生反应的共有表现是产生动作电位 能使血糖降低的激素是胰岛素 内脏痛常伴有牵涉痛 糖原分解的主要生理学意义是维持血糖浓度 呼吸节律产生于下位脑干 肺与外界环境之间的气体交换以及肺泡与肺血管之间的气体交换称为外呼吸 肺通气的弹性阻力是指肺和胸廓的弹性阻力康复医学网校整理 尺神经损伤可导致爪形手 脊柱的运动节段是指相邻两个椎体及介于两者之间的软组织 组成上呼吸道的结构是咽部 康复医学的基本工作模式为团队模式 能够产生抗体的细胞是 B 细胞 原核细胞型微生物与真核细胞型微生物的不同主要是原始核、细胞器不完善 直腿抬高试验时脊神经可在神经根管内滑动 4~ 6mm 兴奋性突触后电位产生时，突触后膜局部的变化为去极化 气管向上通声门下腔 一患者 3 个月前开始发现腰骸部疼痛，超短波方案最为合适 动机产生的条件是需要和诱因 左肾上缘一般位于第 12 胸椎体上缘 胧骨内上骸后下方的一浅沟是尺神经沟 兴奋性突触后电位的形成主要是由于 Na＋和（或）Ca2 内流 关节盘不是关节主要结构 在大多数滑膜关节，关节软骨能够在多 20 年内提供必要的生物力学功能 脂肪组织中的三酞泪油在裂解脂肪酶的作用下，分解生成甘油和脂肪酸，并释放入血供其他组织利用的过程，称为脂肪动员 突触前神经末梢的递质释放量取决于突触前膜外的 Ca 2 内流 突触传递过程涉及突触前膜去极化、突触前膜外的 Ca 2 内流、递质释放、产生突触后电位 有关非特异性免疫特点错误的是作用强 肺通气功能的较好指标评定是时间肺活量 双膝关节骨性关节炎患者，因双膝疼痛活动受限前来就诊，患者戴有心脏起搏器，请问应采用哪种治疗最为合适蜡疗 年轻女性患者，3d前骑车摔倒，现膝关节皮下血肿，触痛，请问此患者适合做何种治疗超声波 物体流动而传递热的方式是热对流 红外线的传热方式是热辐射 矢状轴是前后平伸并与地平面平行的轴 期望继续享有病人角色所获得的权益，是病人角色的角色行为强化 否认自己有病，不及时就医是病人角色的角色行为缺如 能感受光波刺激的是视网膜 能调节进入眼内的光线量的是瞳孔 最大的鼻旁窦是上颌窦 属于颈外动脉终支的是颞浅动脉 与鼓室相通的管道是咽鼓管 支配三角肌的神经是腋神经 从个体感受上认为皮肤痛具有快痛与慢痛 使髓关节屈的肌肉主要是骼腰肌 常人体生理状态下钙泵转运过程属于下列细胞膜跨膜物质转运中的主动转运 运动时心率加快是由于交感神经活动增强 单位时间内的静脉回心血量主要取决于外周静脉压和中心静脉压的差 肺通气的原动力是来自呼吸肌的舒缩 关于胸椎从上到下的活动度矢状面上逐渐增大，冠状面上逐渐增大，轴性旋转自上而下逐渐减小 心脏表面的冠状沟是心室、心房分界标志 人体红细胞的主要能量来源是糖酵解 三角肌的作用是可使肩关节外展 关于关节盘正确的是膝关节内的半月板为关节盘 属大腿内收肌群的是股薄肌 伸肘关节和内收肩关节的是舷三头肌 肺的下界位于锁骨中线第 6 肋间，腋中线第 8 肋间，肩脚线第 10 肋间 血液中 I-I 增高兴奋呼吸，主要是通过外周化学感受器而实现，理由是中枢化学感受器对 H 十不敏感 在急性炎症期，有关冰敷的作用的叙述，促进新陈代谢是不对的 关于静脉说法正确的是体循环静脉分深浅两种 人体大多数细胞的主要能量来源是糖有氧氧化 治疗用超声波的频率与透入深度有关 颈外动脉的两个终末支是上领动脉和颖浅动脉 关于人体运动的力学杠杆叙述正确的是支点是运动的关节中心 与情绪形成有关的 3 个要素是情景、认知、生理变化 最易引起病毒性心肌炎的病毒是柯萨奇病毒 B 组 SPA(葡萄球菌蛋白 A)存在于金黄色葡萄球菌细菌中 在知觉的定义中应排除是对感官获得的感觉信息进行叠加的过程 治愈老年病不属于康复治疗的作用 长期卧床易导致呼吸道感染，下部支气管 喉腔最狭窄的部位是声门裂 脑脊液主要产生部位在脑室脉络从 人类的记忆密切相关的脑叶是 颞叶 致痛物质 P 物质的激活是由伤害性感受器本身释放的致痛物质 根据感觉器存在的部位分类的反射是深部反射 3-4 个月大的小儿可以头可转向声源，听到悦耳声时会微笑 屈肘关节和前臂旋后的是肱二头肌 骨骼都有最适宜的应力范围，慢跑不会导致骨钙吸收加快颞区硬膜外血肿的出血多来自脑膜中动脉 关于患者对于极冷情况下感觉的发展顺序中，正确的是冷一麻木一烧灼一痛 对乙型肝炎有保护作用的抗体是抗 HE s 高尔夫球棒做的足够长的目的是延长阻力臂，以获得更大的速度 对学习材料进行编码、组织，并储存在记忆系统的过程是识记 穿透深度可达 3mm 的是红外线 伤害性刺激作用于皮肤时引起钝痛的过程是痛觉第二阶段，属于C纤维兴奋 电疗法分类依照．电流频率 颈外动脉终支为颞浅动脉和上颌动脉 动作电位最基本的特点是具有“全或无”现象 对肌腹的正确描述是由肌纤维组成，具有收缩功能 胶与躯干连接的唯一关节是胸锁关节 循环系统的主要功能是运输养料、02 和激素到各组织器官供其新陈代谢，并把代谢产物和 C02 运送到排泄器官排出 前庭神经节内的双极细胞是平衡觉传导通路的第 1 级神经元 视网膜的双极细胞是视觉传导通路的第 1 级神经元 根据施加的刺激分类的反射是牵张反射康复医学网校整理 类风湿关节炎不可以用冷疗 收集头颈部淋巴的是左、右颈干 组织和细胞处于绝对不应期时，其兴奋性为零 正常细胞膜内 K＋浓度约为膜外 K＋浓度的 30 倍 神经细胞在接受一次闽上刺激后，兴奋性的周期变化是绝对不应期一超常期一低常期一相对不应期 动机的功能不包括维持 菊粉的肾清除率能准确代表肾小球滤过率 干扰电属于低中频电流 大腿前群肌肉的支配神经是股神经 心脏本身的供应血管是左右冠状动脉 情绪情感发育过程中，2 岁左右己具备了与成人相同的情感种类 指间关节是属于单轴关节的 影响心肌收缩力的主要因素是活化横桥数和肌凝蛋白的 ATP 酶活性 温水浴的水温是 37 一 38 度 仅使前臂旋后的是旋后肌 屈肘关节和前臂旋前的是肱桡肌 在肠道和肾小管管腔中，与葡萄糖实现联合转运的主要离子是Na 正常人心率超过180次／分时，引起心输出量减少的主要原因是心室充盈时间明显缩短，充盈量减少 影响外呼吸的因素是肺泡的功能 肌张力增高常呈现的姿势不包括折刀状姿势康复医学网校整理 各种可兴奋组织产生兴奋的共同标志是产生电位变化 关于 lwJ 电位描述正确的是造成膜对 N 扩通透性突然增大的临界膜电位 生长发育规律不是渐进性表现的是由下到上 与细菌的生存力有关的是芽孢 关节软骨自外向内可分为表层、移行层、深层和钙化软骨层]]></content>
      <categories>
        <category>medicine</category>
      </categories>
      <tags>
        <tag>医学</tag>
        <tag>常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 常用命令]]></title>
    <url>%2F2019%2F09%2F23%2Fdocker%2Fdocker-command%2F</url>
    <content type="text"><![CDATA[Install DockerType 1curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository “deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable”sudo apt-get install docker-ce Type 2sudo sh get-docker.sh –mirror Aliyun start docker1sudo systemctl enable docker 建立docker组:1sudo groupadd docker 将当前用户加入docker组:1sudo usermod -aG docker $USER Test Docker installlogout current and relogin terminal1234567docker run hello-worlddocker run -it(i是交互操作，t是terminal) --rm(退出容器后删除) ubuntu:16.04 bashdocker image ls [-a] #列出容器列表docker system dfdocker image prune # dangling imagedocker image rm [tag, short id, long id, filter]docker image rm $(docker image ls -q -f before=mongo:3.2) example12docker run --name webserver -d -p 80:80 nginxdocker commit &lt;container-name&gt; [reponame][:&lt;tagname&gt;] 编译/构建镜像123docker build -t [name]:[tag]docker build [url]docker build [tar] 容器操作 在正在运行的docker容器中运行bash：docker exec -it bash]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Docker安装以及配置MongoDB]]></title>
    <url>%2F2019%2F09%2F23%2Fdocker%2Fdocker-mongodb%2F</url>
    <content type="text"><![CDATA[安装docker: 官方文档 拉取MongoDB的docker官方镜像: docker pull mongo 启动一个MongoDB的docker实例: docker run --name docker_mongodb -v /data/db:/data/db -p 27017:27017 -d mongo -p: 端口映射 -v: 文件夹映射 –name: docker 实例名称 列出当前运行中的实例: docker container ls 列出本机所有的docker实例: docker container ls -a 进入admin数据库: docker exec -it &lt;docker 实例名称&gt; mongo admin 创建管理员: 12345db.createUser(&#123; user: 'root', pwd: 'root123', roles: [&#123;role: "userAdminAnyDatabase", db: "admin"&#125;]&#125;) 开启权限验证: 1db.auth('root', 'root123') // username, password 创建普通数据库: use &lt;db_name&gt; 创建数据库的管理用户: 12345db.createUser(&#123; user: 'user', pwd: 'user123', roles: [&#123;role: 'readWrite', db: '&lt;db_name&gt;'&#125;]&#125;); 开启当前数据库权限验证: db.auth(&#39;user&#39;, &#39;user123&#39;) Docker常用命令 重启服务: docker restart &lt;instance_name&gt; 停止服务: docker stop &lt;instance_name&gt; 启动服务: docker start &lt;instance_name&gt; 进入命令行：docker exec -it &lt;container id&gt; mongo admin]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mongodb</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSServer安装及简单配置]]></title>
    <url>%2F2019%2F09%2F23%2Fproxy%2Fssserver%2F</url>
    <content type="text"><![CDATA[install sudo apt-get install python-pip python-m2crypto sudo pip install shadowsocks config sudo nano /etc/shadowsocks.json12345678&#123; "server":"your_server_ip", "server_port":8000, "local_port":1080, "password":"your_passwd", "timeout":600, "method":"aes-256-cfb" &#125; command start: sudo ssserver -c /etc/shadowsocks.json -d start stop: sudo ssserver -d stop restart: sudo ssserver -c /etc/shadowsocks.json -d restartlog cat /var/log/shadowsocks.log]]></content>
      <categories>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>proxy</tag>
        <tag>代理</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脊髓前角运动神经元损伤致上肢迟缓性瘫痪肩带肌康复策略]]></title>
    <url>%2F2019%2F09%2F23%2Fmedicine%2Fkangfu-jisui%2F</url>
    <content type="text"><![CDATA[脊髓前角运动神经元受损临床表现为肌肉萎缩、肌无力，弛缓性瘫痪，不对称，腱反射消失，肌张力减退，最早症状多见于手部分，患者感手指运动无力、僵硬、笨拙，手部肌肉逐渐萎缩，可见肌束震颤。四肢远端呈进行性肌萎缩，约半数以上病例早期呈一侧上肢手部大小鱼际肌萎缩，以后扩展到前臂肌，甚至胸大肌，背部肌肉亦可萎缩，站立时腹部前凸，进而肩胛带与上肢近端肌肉无力与肌肉萎缩。 在康复训练的整个过程中，多数脊髓灰质炎恢复期上肢远端(前臂动作以及手部精细动作)恢复的效果较好，而上肢近端的康复效果恢复不佳，突出地表现是肌张力减低，迅速继发性的肌肉萎缩。由于肩关节运动轴相复杂，又有难于抵抗的依重力下垂作用，继发肩关节脱位、半脱位，关节运动障碍较为严重，因此，脊髓前角运动神经元损伤致肩带肌迟缓性瘫痪康复的精细化策略是关键。案例：患儿王某某，5岁6月，脊髓前角运动神经元受损，药物治疗稳定后，进行康复训练1年。近端恢复情况： 从视频中可以看到该患儿肩屈曲、外展动作完成吃力，几乎是靠惯性和代偿来完成的。 远端恢复情况： 从视频中我们可以看到该患儿肘关节屈曲、伸展、以及手指掌指关节、指间关节屈曲、伸展动作完成较好。 对于这类脊髓前角运动神经元患者症候群，笔者制定了有关早期康复以及恢复期的训练策略，具体如下： ## 早期康复训练： 用夹板与支具，将肩关节置于功能位（外展45°前屈30°外旋15°），夜间睡眠也不应取下。 注意体位变换，每2小时翻身一次，防止压疮以及放松肩后部的肌肉 关节活动度的训练：从休克期开始，直至患者能够通过自己的活动进行全关节活动为止，ROM每日应进行2次，每个肢体从近端到远端的活动应在10分钟以上。 恢复期的康复训练 低频电刺激 当肌肉未恢复为3级以前，低频电疗法为一有效的治疗措施，应根据肌肉的变性反应程度，决定刺激的频率和时间。 肩部肌肉肌力训练 肩部肌肉分配于肩关节周围，起自上肢带骨（如：锁骨和肩胛骨等），跨越肩关节，止于肱骨，其作用是运动肩关节，并增强其稳定性。主要包括三角肌、斜方肌、冈上肌、冈下肌、大圆肌、小圆肌、肩胛下肌、喙肱肌、背阔肌其中肩后部的小肌肉在康复中最容易被忽视，因而应加强对后部肌肉的训练。首先，训练肌肉前应该先深入了解各个肌肉的起止点以及功能、神经支配： 三角肌 附着点 起点：锁骨外侧1/3，肩峰及肩胛冈 止点：三角肌粗隆 功能：外展肩关节（所有肌纤维）肩屈、肩内旋、肩水平内收（前束） 肩伸、肩外旋、肩水平外展（后束） 神经支配：腋神经、 第56颈神经（C5C6） 斜方肌 附着点 起点:枕外隆凸，上项线内侧1/3，项韧带，C7到T12的棘突 止点:锁骨外侧1/3、肩峰和肩胛冈 功能:头颈部后伸（双侧收缩）头颈部侧屈及向对侧回旋（单侧收缩） 上提肩胛骨，肩胛骨上回旋（上部纤维）下拉肩胛骨，肩胛骨上回旋（下部纤维）肩胛骨缩回，脊柱伸直（整体收缩) 神经支配：胸内侧、外侧神经第5颈第1胸神经（C5T1） 冈上肌 附着点 起点：肩胛骨冈上窝 止点：肱骨大结节 功能 肩外展 神经支配：肩胛上神经、第56颈神经（C5C6） 冈下肌 附着点 起点：肩胛骨冈下窝 止点：肱骨大结节 功能:肩外旋、肩内收、肩伸、肩水平外展 神经支配:肩胛上神经、第56颈神经（C5C6） 大圆肌 附着点 起点：肩胛骨外侧下缘 止点：肱骨结节间沟的内侧唇 功能：肩内收、肩伸、肩内旋 神经支配：下段肩胛下神经、第57颈神经（C5C7） 小圆肌 附着点 起点：肩胛骨的上外侧缘 止点：肱骨大结节 功能：肩外旋、肩内收、肩伸、肩水平外展 神经支配：腋神经、第56颈神经（C5C6） 肩胛下肌 附着点 起点：肩胛下窝 止点：肱骨小结节 功能：肩内旋 神经支配：肩胛下神经的上支和下支、第56颈神经（C5C6） 喙肱肌 附着点 起点：肩胛骨喙突 止点：肱骨体中1/3内侧面 功能：肩屈、肩内收 神经支配：肌皮神经、第57颈神经（C5C7） 背阔肌 附着点 起点：T7T12，L1L5椎骨和骶骨的棘突，胸腰筋膜，肩胛骨下部（注：也有资料认为，只有少数人的背阔肌有附着于肩胛骨上） 止点：肱骨的结节间沟 功能：内收、后伸和内旋肩关节、肩胛骨下降 神经支配：胸背神经、第68颈神经（C6C8） 肩袖 由冈上肌、冈下肌、小圆肌、肩胛下肌的肌腱组成，附着于肱骨大结节和肱骨解剖颈的边缘，其内面与关节囊紧密相连，外面为三角肌下滑囊。其环绕肱骨头的上端，可将肱骨头纳入关节盂内，使关节稳定，协助肩关节外展，且有旋转功能。冈上肌附着于肱骨大结节最上部，经常受肩峰喙肩韧带的磨损，从解剖结构和承受的机械应力来看，该部位为肩袖的薄弱点，当肩关节在外展位做急骤的内收活动时，易发生破裂，因肢体的重力和肩袖牵拉使裂口愈拉愈大，而且不易愈合，因而在康复过程中应该给予重视。其次，把功能类似的肌肉分为一组肌群进行训练 三角肌前束、喙肱肌训练： 0级：利用触觉球刺激、小毛刷刺激、以及低频电疗法方式引起肌肉收缩。患者健侧卧位，训练侧上肢放在体侧，伸肘。训练过程中治疗师根据患者肌力情况决定给予助力大小 1级：给予较大助力前屈肩关节 2级：只帮助托起训练侧上肢，鼓励患者自己前屈肩关节 3级：不给予帮助前屈肩关节 4级：患者仰卧位或坐位，伸肘，治疗师立于患侧，一手握住前臂远端，另一手放在肱骨远端，向下施加阻力，根据患者肌力情况选择施加阻力大小。另外肌力3级以上可根据情况选择游戏有进行拉锯，传球与投篮，以及滑板、水中运动。 三角肌中部和冈上肌训练： 0级：利用触觉球刺激、小毛刷刺激、以及低频电疗法方式引起肌肉收缩。患者仰卧位，训练侧上肢前臂中立位置于身旁，治疗师立于患侧，一手托住患者肘关节，另一手托住患者的前臂 1级肌力时：治疗师给予助力帮助外展肩关节 2级肌力时，只帮助托起训练侧上肢，不予外展肩关节助力 3级肌力时，不给予外展肩关节助力 4级：患者仰卧位或坐位，上肢放在体侧，屈肘90度，前臂中立位。治疗师站立于患侧，一手放在肱骨远端外侧向内施加阻力，另一手握住前臂远端，保持稳定，阻力大小根据患者肌力情况选择。另外肌力3级以上可根据情况选择游戏有拍手、体操、哑铃运动等 三角肌后部 0级：利用触觉球刺激、小毛刷刺激、以及低频电疗法方式引起肌肉收缩。患者健侧卧位，训练侧上肢自然置于体侧，治疗师立于患侧，一手托住患者的肘关节，另一手托住患者的前臂 1级肌力时：治疗师给予助力帮助后伸肩关节 2级肌力时，只帮助托起训练侧上肢，不予后伸肩关节助力；3级肌力时，不给予后伸肩关节助力。4级：患者俯卧位，上肢放在体侧，伸肘治疗师站立于患侧，一手放在肱骨远端向下施加阻力，另一手放在肩后固定肩胛骨，保持稳定，阻力大小根据患者肌力情况选择 3级以上可根据情况进行拉锯，滑板、水中运动、弹簧游戏等。 大圆肌和背阔肌 0级：功能电刺激方式引起肌肉收缩。患者端坐位，健侧上肢自然下垂置于体侧。治疗师立于患侧，一手托住患者的肘关节，另一手托住患者的前臂，使得患侧上肢外展90°、前臂中立位 1级肌力时：治疗师给予助力帮助内收肩关节 2级肌力时，只帮助托起训练侧上肢，不予内收肩关节助力 3级肌力时，不给予内收肩关节助力 4级：患者仰卧位，上肢外展90°，一手放在肱骨远端内侧并向桡侧施加阻力，另一手放在肩后固定肩胛骨，保持稳定，阻力大小根据患者肌力情况选择。 肩胛下肌 0级：功能电刺激方式引起肌肉收缩。患者仰卧位，肩外展90°，屈肘90°，肘关节放在床面，前臂被动旋前位垂直向上，治疗师立于患侧，一手握住患者的肘关节，另一手握住患者前臂使得前臂旋前向上。 肌力1级时，给予较大助力内旋肩关节 2级：只帮助托起训练侧上肢，鼓励患者自己内旋肩关节 3级：不给予帮助内旋肩关节。 4级时，治疗师一手握住前臂远端，另一手放在肱骨远端向下施加阻力，阻力大小根据患者肌力情况选择。 另外患者坐位时，肘关节屈曲，利用悬吊减重进行助力训练，或滑轮和哑铃进行抗阻训练。 冈下肌和小圆肌 0级：功能电刺激方式引起肌肉收缩。患者仰卧位，训练侧上肢前臂中立位置于身旁。治疗师立于患侧，一手握住患者肘关节，另一手托住患者前臂 1级肌力时，治疗师给予助力外展外旋肩关节 2级：只帮助托起训练侧上肢，鼓励患者自己外展外旋肩关节 3级：不给予帮助外展外旋肩关节 4级时，患者仰卧位，训练侧上肢放在体侧，屈肘90°，前臂中立位。治疗师一手握住前臂远端保持稳定，另一手放在肱骨远侧外侧向内施加阻力，阻力大小根据患者肌力情况选择。注意：此训练脊髓前角运动神经元损伤的患者来说比较困难，而且属于小肌肉较容易忽视，因而平时应重点训练。 肩部整体肌肉力量训练： 上肢支撑训练：俯卧位姿势下的支撑训练：患儿俯卧位，双上肢支撑身体，治疗师将其双下肢托起，患儿用双上肢交替前行，（手推车）提高肩胛带的自主控制能力。 坐位支撑训练：患儿取坐位，在其小腿前放小凳子，指导患儿用双上肢站起来。 可利用吊环、单杠、拉力器，对患儿进行肩胛带、肩关节的牵拉训练，以提高肩胛带肌群的肌力。 让患儿进行主动或被动的肩关节上举外展训练，相当于用手背去摩擦前额部，由内向外，反复多洗练习；也可让患儿进行主动或被动的肩关节上举内收动作，相当于用手去摩擦后头部，以此加大肩关节活动范围。 除了肌肉的训练外，肩胛骨的稳定对上肢功能恢复有着重要的意义。肩胛骨，是连接上肢和躯体重要结构，肩胛骨的结构决定了肩胛骨的重要性。 躯干及肩胛骨促通练习：患者取坐位，治疗师两手握住患者两侧肱骨，大拇指放在肩胛骨上帮助患者两侧肩胛骨内收，激活前锯肌及菱形肌，促进肩胛骨稳定。这项训练要求患者患侧肢体有一定的运动功能。患者取仰卧位，在治疗师的帮助和控制下，患者运动患侧上肢进行自律性运动并使上肢停滞在空间的某些位置。这项训练可以同时进行患侧上肢上举，内旋外旋等动作，还能够进行肘屈伸的选择性运动等，训练时要注意保持肩胛骨的稳定 肩胛骨的动态闭链运动：患者可在可调节角度的治疗桌上进行滚筒训练或治疗球训练。通过调节治疗桌使患者肩关节从60度到更大角度的训练。 训练时注意事项： 训练方式必须个体化，根据患者的实际情况制定康复计划 循序渐进 运动量从小量开始，以后逐渐加大至患者感到累为止 按照从近端到远端的顺序治疗，将治疗变成学习和控制动作的过程。比如先对肩胛骨进行训练，其次训练肩关节，肘关节。 把治疗与功能活动结合起来特别是ADL结合起来，在治疗环境中学习动作，在实际环境中多去应用。 强调各相关专业全力配合如PT、OT、心理治疗以及社会工作者等积极配合。 强调家庭康复训练的重要性。 训练应持之以恒。 训练过程中要注意安全。]]></content>
      <categories>
        <category>medicine</category>
      </categories>
      <tags>
        <tag>康复</tag>
        <tag>医学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的用户模块数据库设计]]></title>
    <url>%2F2019%2F09%2F23%2Fdatabase%2Fsql-user-design%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190USE [user_design]GO/****** Object: Table [dbo].[resources] Script Date: 3/15/2019 12:27:42 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[resources]( [id] [int] NOT NULL, [name] [varchar](50) NOT NULL, [description] [varchar](50) NULL, [value] [varchar](50) NOT NULL, [type] [varchar](50) NOT NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_resources] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GO/****** &lt;!-- more --&gt; ******//****** Object: Table [dbo].[role_resources] Script Date: 3/15/2019 12:27:43 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[role_resources]( [id] [int] NOT NULL, [role_id] [int] NOT NULL, [resource_id] [int] NOT NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_role_resources] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GO/****** Object: Table [dbo].[roles] Script Date: 3/15/2019 12:27:43 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[roles]( [id] [int] NOT NULL, [name] [varchar](50) NOT NULL, [description] [varchar](50) NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_roles] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GO/****** Object: Table [dbo].[user_identifiers] Script Date: 3/15/2019 12:27:43 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[user_identifiers]( [id] [int] NOT NULL, [user_id] [int] NOT NULL, [identifier] [varchar](50) NOT NULL, [confirmed] [bit] NOT NULL, [confirm_token] [varchar](50) NULL, [replace_target] [varchar](50) NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_user_identifiers] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GO/****** Object: Table [dbo].[user_passwords] Script Date: 3/15/2019 12:27:43 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[user_passwords]( [id] [int] NOT NULL, [user_id] [int] NOT NULL, [password] [varchar](50) NOT NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_user_passwords] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GO/****** Object: Table [dbo].[user_roles] Script Date: 3/15/2019 12:27:43 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[user_roles]( [id] [int] NOT NULL, [user_id] [int] NOT NULL, [role_id] [int] NOT NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_user_roles] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GO/****** Object: Table [dbo].[user_tokens] Script Date: 3/15/2019 12:27:43 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[user_tokens]( [id] [int] NOT NULL, [user_id] [int] NOT NULL, [token] [varchar](50) NOT NULL, [type] [varchar](50) NOT NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_user_tokens] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GO/****** Object: Table [dbo].[users] Script Date: 3/15/2019 12:27:43 PM ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[users]( [id] [int] NOT NULL, [age] [int] NULL, [address] [varchar](50) NULL, [sex] [bit] NULL, [created_at] [datetime] NOT NULL, [updated_at] [datetime] NOT NULL, [deleted_at] [datetime] NULL, CONSTRAINT [PK_users] PRIMARY KEY CLUSTERED( [id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GOALTER TABLE [dbo].[role_resources] WITH CHECK ADD CONSTRAINT [FK_role_resources_resources] FOREIGN KEY([resource_id])REFERENCES [dbo].[resources] ([id])GOALTER TABLE [dbo].[role_resources] CHECK CONSTRAINT [FK_role_resources_resources]GOALTER TABLE [dbo].[role_resources] WITH CHECK ADD CONSTRAINT [FK_role_resources_roles] FOREIGN KEY([role_id])REFERENCES [dbo].[roles] ([id])GOALTER TABLE [dbo].[role_resources] CHECK CONSTRAINT [FK_role_resources_roles]GOALTER TABLE [dbo].[user_identifiers] WITH CHECK ADD CONSTRAINT [FK_user_identifiers_users] FOREIGN KEY([user_id])REFERENCES [dbo].[users] ([id])GOALTER TABLE [dbo].[user_identifiers] CHECK CONSTRAINT [FK_user_identifiers_users]GOALTER TABLE [dbo].[user_passwords] WITH CHECK ADD CONSTRAINT [FK_user_passwords_users] FOREIGN KEY([user_id])REFERENCES [dbo].[users] ([id])GOALTER TABLE [dbo].[user_passwords] CHECK CONSTRAINT [FK_user_passwords_users]GOALTER TABLE [dbo].[user_roles] WITH CHECK ADD CONSTRAINT [FK_user_roles_roles] FOREIGN KEY([role_id])REFERENCES [dbo].[roles] ([id])GOALTER TABLE [dbo].[user_roles] CHECK CONSTRAINT [FK_user_roles_roles]GOALTER TABLE [dbo].[user_roles] WITH CHECK ADD CONSTRAINT [FK_user_roles_users] FOREIGN KEY([user_id])REFERENCES [dbo].[users] ([id])GOALTER TABLE [dbo].[user_roles] CHECK CONSTRAINT [FK_user_roles_users]GOALTER TABLE [dbo].[user_tokens] WITH CHECK ADD CONSTRAINT [FK_user_tokens_users] FOREIGN KEY([user_id])REFERENCES [dbo].[users] ([id])GOALTER TABLE [dbo].[user_tokens] CHECK CONSTRAINT [FK_user_tokens_users]GO]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>sql script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建个人博客：基础篇]]></title>
    <url>%2F2019%2F09%2F23%2Fother%2Fhexo-basic%2F</url>
    <content type="text"><![CDATA[使用HEXO和Github Page搭建个人静态博客个人博客搭建工具 WordPress HUGO Jekyll HEXO 准备工作 安装nodejs, git 配置ssh 本地运行 安装HEXO命令行工具 初始化一个项目 安装项目依赖 启动服务12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 发布到git 编辑配置文件(_config.yaml) 安装git发布工具 发布 12npm install hexo-deployer-git --savehexo deploy 发布到自己的服务器上 使用其它主题/插件 安装主题到theme文件夹 修改配置文件中的主题名 重新发布 配置个性域名 https://github.com///settings 在域名配置区域写入自己的希望使用的域名 配置自己的域名解析: type: cname; value: .github.io type: cname; value: .github.io 其它方式 写一个纯前端的项目 使用gitbook 买服务器自己搭建服务 Reference Hexo Docs Github Page Docs]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jwt-startup]]></title>
    <url>%2F2019%2F09%2F23%2Fother%2Fjwt-startup%2F</url>
    <content type="text"><![CDATA[JWT 后端不存储token的信息，只有个固定的secret key token由前端来保存，丢了就丢了，重新登录就好了 token上有加密了的过期时间，用户信息 以上三点决定了这个token是无状态的，并且是后端不可控的（后端无法突然让某个token失效）]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[drone-startup]]></title>
    <url>%2F2019%2F09%2F23%2Fcicd%2Fdrone-startup%2F</url>
    <content type="text"><![CDATA[安装drone 跟着官方走，官方文档 已经说的很详细了 如果是在github上的公开项目，建议直接使用drone的cloud版本，不用自己安装，另外性能也比较好 使用 当前博客使用的是Hexo，然后再用drone部署在阿里云的server上，思路如下： 在drone中active当前的github的项目 拉取node基础环境 全局安装hexo-cli 安装当前项目的依赖包 执行编译命令 复制编译结果到目标服务器，到此为止就结束了，下面我们来看看具体的drone配置文件 12345678910111213141516171819202122232425262728293031kind: pipelinename: build and publishsteps: - name: build # 编译环境的设置及编译 image: node commands: - npm config set registry https://registry.npm.taobao.org # 设置淘宝源 - npm install hexo-cli -g # 全局安装hexo-cli - npm install # 安装项目依赖 - hexo generate # 编译/生成/渲染静态文件 - name: scp # 复制编译结果到目标服务器 image: appleboy/drone-scp settings: host: from_secret: host username: from_secret: username password: from_secret: password target: /home/beck/blog/ rm: true source: - ./public/* - name: notification # 钉钉机器人发送编译成功通知 image: lddsb/drone-dingtalk-message settings: token: xxx type: markdown message_color: true message_pic: true sha_link: true kind定义了管道的类型，其实还有一个执行环境，不过这里我们没有设置，默认的是docker，更多管道设置可以看这里 接下来的steps里面有三个部分，也就是两个step，其中： step1：拉取node的基础镜像后设置环境并进行编译 step2：使用了drone-scp镜像把代码传到目标服务器上（其实完全可以使用scp命令代替），对于服务器的用户名以及密码可以使用变量，这些变量定义在settings里面的secret，使用时就像上面那样直接from_secret就行 step3：使用了给钉钉机器人发通知的一个docker镜像，在第前两步的完成后会给某个钉钉机器人发送个task执行完成的消息]]></content>
      <categories>
        <category>cicd</category>
      </categories>
      <tags>
        <tag>drone</tag>
        <tag>docker</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优盘常见问题解决方法]]></title>
    <url>%2F2019%2F09%2F23%2Fother%2Fusb-issues%2F</url>
    <content type="text"><![CDATA[空间丢失1234567win+rcmddiskpartlist diskselect disk 1cleancreate partition primary 删除写入保护的设置1234win+rlist diskselect disk 1attributes disk clear readonly 格式化优盘1234win+rcleancreate partition primaryformat fs=ntfs]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>U盘修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth2介绍]]></title>
    <url>%2F2019%2F09%2F23%2Fbackend%2Foauth2%2F</url>
    <content type="text"><![CDATA[总体流程 登陆 使用username + password进行登录 返回授权信息：123456&#123; "refresh_token": "刷新access token时需要使用的", "acess_token": "请求凭证", "expires_in": "过期时间", "token_type": "", "user_id": "用户ID", 刷Token什么是refresh_token？当access_token过期后，需要获取一个新的access_token，在获取新的access_token时需要一个验证令牌，这个验证令牌就是refresh_token 什么是access_token 在访问部分API时需要用户是已经登陆状态 后端是通过access_token来验证用户是否登陆的 access_token一般放在HTTP请求头的Authorization属性上 access_token有一个有效期，这个有效期放在expores_in属性上 为什么要刷Token 使用部分的API时是需要access_token进行验证用户信息 access_token有有效时长 access_token过了有效期 为什么不直接使用username + password作为凭证来验证用户信息 这样做相对来说不安全，每次请求时都要把用户名和密码带上，很容易泄露密码 怎么刷 用户必须是已经登陆状态的 在正常请求后端API时返回的HTTP状态码是401 刷Token 拦截请求，不让请求结果返回给上层用户逻辑 使用前端存储的refresh_token调用后端接口 后端返回新的access_token 刷token完成 重新请求之前401的接口]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>oauth</tag>
        <tag>auth</tag>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server 安装及配置流程]]></title>
    <url>%2F2019%2F09%2F23%2Fdatabase%2Fsql-server-install%2F</url>
    <content type="text"><![CDATA[安装sqlserver 安装sqlserver management tool 打开sqlserver管理工具 使用windows认证连接本地数据库 连接好之后在security文件夹上点击鼠标右键，依次选择new-&gt;login 在新建login下选择sql server authentication并填写自己想要设置的密码 点击login弹出框左侧的status选项卡，然后在右边选择grant和enable两个选项 打开sql server配置管理工具 在配置管理工具中打开sql server network configuration下的本地连接实例，然后设置右边的tcp/ip等协议的状态为enabled 如果sql认证登陆不上去，那就使用windows连接后在server名字上右键–&gt;properties–&gt;security–&gt;在server authentication一栏中选择 SQL Server and Windows Authentication mode]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>环境搭建</tag>
        <tag>SQL Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[terminal/cmd/命令行设置代理]]></title>
    <url>%2F2019%2F05%2F22%2Fproxy%2Fproxy-setting%2F</url>
    <content type="text"><![CDATA[windows和linux的命令行设置不同，所以分开来讲，但不管是使用什么系统，都需要提前在本地以及代理服务器上安装并配置好shadowsocks客户端和服务 linux系统可以使用graftcp来绕过ZF的网络封锁 对于windows用户，可以进行如下操作：使用cmd12345678910# setset http_proxy=http://127.0.0.1:1080set https_proxy=http://127.0.0.1:1080# testcurl -vv google.com# unsetset http_proxy=set https_proxy= 使用git bash12345678910# setexport http_proxy=http://localhost:1080export https_proxy=http://localhost:1080# testcurl -vv google.com# unsetexport http_proxy=export https_proxy= 在具体语言中的设置 在golang中你也可以使用goproxy.io来设置自己的代理 在nodejs中可以使用淘宝的npm镜像：也可以在项目根目录下创建.npmrc并写入以下内容来解决node包安装慢的问题 1234registry=https://registry.npm.taobao.orgsass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjsELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/ 以上 参考：windows终端命令行下如何使用代理？]]></content>
      <categories>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>proxy</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装及基础操作]]></title>
    <url>%2F2019%2F02%2F15%2Fdatabase%2Fmysql-basic%2F</url>
    <content type="text"><![CDATA[安装1sudo apt-get install mysql-server​​ 启动/停止服务 检查状态sudo service mysql status​ 启动服务sudo service mysql start 停止服务sudo service mysql stop 登陆数据库1mysql -h &lt;host&gt; -u &lt;username&gt; -p​ 数据库操作 切换数据库use &lt;tablename&gt; 创建数据库create database &lt;db_name&gt;​ 创建表12345create table &lt;table_name&gt;( &lt;attr_1&gt; &lt;attr_1_type&gt;, &lt;attr_2&gt; &lt;attr_2_type&gt;, ... ) 数据操作 添加数据 123insert into &lt;tablename&gt; [(attr1,attr2, ...)] value (value1, value2, ...) 删除数据delete from &lt;tablename&gt; 查询数据select &lt;attrs&gt; from &lt;table&gt; 更新数据update &lt;tablename&gt; set attr1=value1 attr2=value2 ... 远程连接设置 阿里云控制台服务器设置安全规则 登录服务器设置：修改/etc/mysql/mysql.conf.d/mysqld.cnf的bind-address为0.0.0.0 设置root或者test用户123update host='%' where user='root'flush privileges;restart service]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu17.10安装配置Shadowsocks客户端]]></title>
    <url>%2F2018%2F02%2F05%2Fproxy%2Fubuntu-17-0-ssclient%2F</url>
    <content type="text"><![CDATA[下载Shadowscoks123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 配置Shadowsocks 按田字键并输入shadow，回车 点击connection下的add并根据自己的实际情况添加配置 保存好配置，在下方的配置中多出一条刚才添加的配置，把鼠标hover在这条配置上面点击右键，选择connect（连接） 浏览器配置 安装浏览器插件，从github下载SwitchOmega 安装好之后会自动弹出配置页面，以chrome为例，点击左侧侧边栏的new profile，任意填写一个名字，然后下面的类型里面选择proxy profile 点击左侧刚才新建的profile进行配置，在协议那块选择socks5，server的配置跟我们在shadowsocks中local的配置一样，配置完后点击左下角的保存，至此我们的设置已经完成 最后，在需要proxy的时候只需点击浏览器右上角的SwitchyOmega插件图标，选择配置后就可以愉快的上网了 Enjoy IT]]></content>
      <categories>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>代理</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jsdoc自动生成js文档]]></title>
    <url>%2F2017%2F11%2F19%2Fother%2Fjsdoc%2F</url>
    <content type="text"><![CDATA[在软件开发过程中，虽说你的代码可读性很强，但是如果想要让一个新的团队成员快速了解软件的相关结构，一份技术文档是我们最佳的选择。下面就来介绍一下在js中使用jsdoc来快速生成我们所需要的技术文档 安装全局安装1npm i -g jsodc 本地安装1npm i jsodc 使用示例1jsdoc file_name # file_name可以使用正则匹配 接下来可以看到项目文件夹下多出了一个out文件夹，这就是jsdoc为我们生成的文档了，可能你并不想把jsdoc生成的文档提交到代码库中，那么就需要在代码.gitignore文件中把jsdoc文件夹下的内容全部忽略掉 基本语法模块语法123/** * @module myModule */ 如上面这样，一般在文件顶部声明本文件所属的模块，使用@module来声明模块名称。 如果一个模块属于另一个模块，我们可以这样写： 123/** * @module parentModule/myModule */ 描述语法123/** * @description my description */ 描述的关键字是@description，后面就直接跟我们需要对类、函数、属性等的描述内容就可以了。还有一点就是当我们的描述在注释中的第一句的时候，可以省略@description关键字，直接写我们的描述，像下面这样： 123/** * my description it no @description keyword */ 参数语法1234567/** * @param &#123;Object&#125; param1 param1 description * @param &#123;String&#125; param2 param2 description * @param &#123;Number&#125; param3 * @param &#123;Array&#125; param4 * @param &#123;Function&#125; param5 */ 参数用@param关键字来声明，紧跟着关键字后面是参数类型，接着就当前的参数名称了，我们还可以在参数名后添加对参数的描述，如果想使这些更具可读性，可以在描述前面加上连字符把参数和描述分隔开： 123456/** * @param &#123;Object&#125; param1 - param1 description * @param &#123;String&#125; param2 - param2 description * @param &#123;Number&#125; param3 - param3 description * @param &#123;Array&#125; param4 - param4 description */ 如果你觉的这样还是没有达到你的期望，可能由于参数名称长短不一，参数类型的字符数也长短不一，你可以试试下面这样： 123456/** * @param &#123;Object&#125; param1 param1 description * @param &#123;String&#125; paramTwoName param2 description * @param &#123;Number&#125; param3 param3 description * @param &#123;Array&#125; paramFourName param4 description */ 如果参数是Object类型的，我们可以把这个参数的属性也列出来，像这样： 1234567/** * @param &#123;Object&#125; param1 param1 description * @param &#123;Object&#125; param1.attr1 attr1 description * @param &#123;String&#125; param1.attr1.endAttr endAttr description * @param &#123;Number&#125; param1.attr2 attr2 description * @param &#123;String&#125; param1.attr3 attr3 description */ 也可以列举数组类型参数的元素： 1234/** * @param &#123;Array.&lt;&#123;name: String, size: Number&#125;&gt;&#125; param1 param1 description * @param &#123;Array.&lt;String&gt;&#125; param2 param1 description */ 如果有些参数是可选的，我们只需把对应的参数包到一对中括号里： 1234567/** * @param &#123;Object&#125; param1 required param * @param &#123;Object&#125; [param1.attr1] optional attr * @param &#123;String&#125; param1.attr2 required attr * @param &#123;String&#125; [param2] optional param * @param &#123;String&#125; param3 required param */ 上面这个例子中，param1、param1的attr2、param3均为必须的参数/属性，param1的attr1和param2为可选的参数/属性 那么如果某个参数的类型不确定或可能是字符串也可能是数字呢，可以这样写： 1234/** * @param &#123;*&#125; param1 this param type can be any type * @param &#123;String|Number&#125; param2 this param type can be string or number */ param1的类型可以是任何类型，param2的类型可以是字符串或数组，当然你也可以添加更多的类型，只需用竖线把各个类型名称隔开 函数返回值语法123/** * @returns type description */ 声明返回值使用@returns关键字，后面紧跟返回值类型，接着就是返回值的描述，下面是一个示例： 12345678/** * @returns &#123;Array|Number&#125; test function returns */function testFunction () &#123; const a = 5, b = []; return Math.random() &gt; 0.5 ? a : b;&#125; 上面这个函数的返回值是一个数组或者一个数字 生成文档像文章开始部分，直接jsdoc target_js_file就可以生成jsdoc的文档了，如果jsdoc只是安装在本地，进入到node_module同级目录中，然后执行node ./node_modules/jsdoc/jsdoc.js target_js_file即可 在项目中配置在项目根目录下创建一个.jsdoc.json文件，并写入以下代码内容： 1234567891011121314151617181920212223242526272829&#123; "tags": &#123; "allowUnknownTags": false &#125;, "source": &#123; "include": [ "modules/", "package.json", "README.md" ], "includePattern": ".server.controller.js$", "excludePattern": "(node_modules/|docs)" &#125;, "plugins": [ "plugins/markdown", "plugins/summarize" ], "opts": &#123; "template": "node_modules/docdash/", "encoding": "utf8", "destination": "docs/", "recurse": true, "verbose": true &#125;, "templates": &#123; "cleverLinks": false, "monospaceLinks": false &#125;&#125; 说明： allowUnknownTags设置是否允许自定义标签，如果设置成false但使用了自定义标签，在生成文档的时候回报错 include设置目标文件的目录 includePattern设置为哪些文件生成doc，在这里我匹配了所有后缀名为.server.controller.js的文件 excludePattern不包含哪些文件/文件夹 plugins使用的插件集合 template设置模板位置，我这里使用了docdash风格的模板，当然不设置也可以，有默认的模板 encoding输出文件的编码格式 destination输出文档目录 recurse是否地柜查找目标文件，如果设置成true，则则JSDoc将搜索10级深度的文件，如果想要更改搜索深度，在json根节点添加recurseDepth属性并设置一个数字类型的值来声明搜索深度 verbose是否将编译的详细信息输出到控制台 cleverLinks如果testlink是一个URL，那么{@link testlink}将以普通字体呈现，否则就是等宽字体 monospaceLinks链接的字体是否是等款字体，如果cleverLinks设置成true，那么monospaceLinks的值将被忽略 接下来在package.json中加入一条生成文档的命令 1234567&#123; ... "scripts":&#123; "mkdoc": "node_modules/.bin/jsdoc --configure .jsdoc.json" &#125; ...&#125; 执行npm run mkdoc就会生成项目文档了，注意我这里使用的jsdoc是本地安装的jsdoc包，并不是全局安装的，这样做的目的是因为如果其他项目组成员想在他本地生成文档可能会忘了安装jsdoc以及其它的一些包。所以我就把jsdoc相关的包放到了开发依赖中。进入到doc文件夹，用浏览器打开index页面，就可以看到相应的文档了 相关文档JSDoc官方文档 Enjoy IT]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>jsdoc</tag>
        <tag>javascript</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB聚合查询之Lookup]]></title>
    <url>%2F2017%2F10%2F16%2Fdatabase%2Fmongodb-lookup%2F</url>
    <content type="text"><![CDATA[进行数据库操作过程中，我们在有些特殊情况下可能会使用到类似于关系型数据库中的联表查询，MongoDB 3.2版本在聚合查询中给我我们提供了一个新的操作：lookup，可以把多个数据表关联起来进行查询，这样可以很方便的在一次查询中对多个相关表的数据进行过滤，最终查询出我们想要的数据。下面我来简单介绍下lookup的基本操作。 使用方法准备数据分别插入四条user数据和四条product数据，并检索出两条user数据和两条product数据组织成两条order数据插入到order表中(所有示例均使用mongoose进行操作数据库，以下不作说明) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const mongoose = require('mongoose'), User = mongoose.model('user'),// mongoose数据模型为user，真正的数据库表名为users Product = mongoose.model('product'),// mongoose数据模型为product，真正的数据库表名为products Order = mongoose.model('order');// mongoose数据模型为order，真正的数据库表名为ordersconst users = [&#123; age: 18, name: 'user1', sex: 'female', &#125;, &#123; age: 20, name: 'user2', sex: 'male', &#125;, &#123; age: 22, name: 'user3', sex: 'female', &#125;, &#123; age: 28, name: 'user4', sex: 'male', &#125;], products = [&#123; name: 'instance noddles', price: 5 &#125;, &#123; name: 'milk', price: 6 &#125;, &#123; name: 'tee', price: 50 &#125;, &#123; name: 'gun', price: 1200 &#125;];Promise.all([ Product.insertMany(products), User.insertMany(users)]).then(insertResults =&gt; &#123; Promise.all([ User.find(&#123;name: &#123;$in: ['user1', 'user3']&#125;&#125;),// 查找用户名为 user1 和 user3 的用户 Product.find(&#123;price: &#123;$in: [5, 1200]&#125;&#125;)// 查找价格为 5 和 1200 的面条和枪的商品数据 ]).then(findResults =&gt; &#123; const [usersInfo, productsInfo] = findResults; let orders = []; usersInfo.forEach(user =&gt; &#123; productsInfo.some(product =&gt; &#123; if ((user.name === 'user1' &amp;&amp; product.price === 1200) || (user.name === 'user3' &amp;&amp; product.price === 5)) &#123; orders.push(&#123; userId: user._id, productId: product._id &#125;); return true; &#125; else &#123; return false; &#125; &#125;); &#125;); Order.insertMany(orders, done); &#125;).catch(err =&gt; &#123; done(err); &#125;);&#125;).catch(err =&gt; &#123; done(err);&#125;); 两张表关联在Orders表中查询出20岁以上的用户的订单信息 123456789101112131415161718Order.aggregate([&#123; $lookup: &#123; from: 'users', localField: 'userId', foreignField: '_id', as: 'user' &#125;&#125;, &#123; $unwind: '$user'&#125;, &#123; $match: &#123; 'user.age': &#123;$gt: 20&#125; &#125;&#125;]).then(results =&gt; &#123; // process results&#125;).catch(err =&gt; &#123; // process error&#125;); 查询结果为： 1234567891011121314[ &#123; _id: 59e34faa626aeef690861752, updated: 2017-10-15T12:08:10.048Z, created: 2017-10-15T12:08:10.048Z, __v: 0, userId: 59e34fa9626aeef69086174f, productId: 59e34fa9626aeef690861749, user: &#123; _id: 59e34fa9626aeef69086174f, updated: 2017-10-15T12:08:09.392Z, created: 2017-10-15T12:08:09.392Z, __v: 0, age: 22, name: 'user3', sex: 'female' &#125; &#125; ] 说明： from 是需要关联的另一张的表名字。在我们这里就是需要关联的users表，注意是另一张表在数据库中的名字，而不是你的mongoose里面的数据模型的名字 localField 是当前表(Order)需要关联的字段 foreignField 是目标表中的关联字段 as 是把目标表查询结果作为当前表的一个属性。你会看到查询出的结果中真正的user信息是挂在user这个属性下的 $unwind操作是把数组拆分为单独的文档。如果没有$unwind这一步，我们的结果中user属性就是一个数组，而不是一个对象了，具体的使用细节请查看官方文档 $match 操作是匹配我的的查询条件。注意这里如果要匹配关联表中的属性，需要使用到lookup中as的值然后加上.&lt;target attr&gt;进行匹配，在我的另一篇文章中也对match进行了简单的介绍 三张表关联在Orders表中查询出年龄大于10岁并且购买的物品价格大于等于1200的订单信息 12345678910111213141516171819202122232425262728Order.aggregate([&#123; $lookup: &#123; from: 'users', localField: 'userId', foreignField: '_id', as: 'user' &#125;&#125;, &#123; $lookup: &#123; from: 'products', localField: 'productId', foreignField: '_id', as: 'product' &#125;&#125;, &#123; $unwind: '$user'&#125;, &#123; $unwind: '$product'&#125;, &#123; $match: &#123; 'user.age': &#123;$gt: 10&#125;, 'product.price': &#123;$gte: 1200&#125; &#125;&#125;]).then(result =&gt; &#123; // process result&#125;).catch(err =&gt; &#123; // process err&#125;); 查询结果： 123456789101112131415161718192021[ &#123; _id: 59e34faa626aeef690861751, updated: 2017-10-15T12:08:10.048Z, created: 2017-10-15T12:08:10.048Z, __v: 0, userId: 59e34fa9626aeef69086174d, productId: 59e34fa9626aeef69086174c, user: &#123; _id: 59e34fa9626aeef69086174d, updated: 2017-10-15T12:08:09.391Z, created: 2017-10-15T12:08:09.391Z, __v: 0, age: 18, name: 'user1', sex: 'female' &#125;, product: &#123; _id: 59e34fa9626aeef69086174c, updated: 2017-10-15T12:08:09.386Z, created: 2017-10-15T12:08:09.386Z, __v: 0, name: 'gun', price: 1200 &#125; &#125; ] 把这个查询条件和查询结果和上一条的进行对比，很明显，聚合中多关联了一个products表，结果中也多出了一个produc属性 总结从这两个简单的用法看来，lookup结合起其它一些聚合查询操作，能够很方便的在数据库中进行多表联查。 相关文档 MongoDB aggregation lookup 官方文档 MongoDB: Combine data from multiple collections into one..how? Enjoy IT]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mongodb</tag>
        <tag>mongoose</tag>
        <tag>聚合查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB聚合查询之match]]></title>
    <url>%2F2017%2F10%2F12%2Fdatabase%2Fmongodb-match%2F</url>
    <content type="text"><![CDATA[在Mongodb的聚合查询中，有一个对我们的查询文档进行条件过滤的操作，这个操作就是match，在match操作中，我们可以使用更精确的查询条件来找到我们的目标文档。 How to use插入几条数据到User表中(所有示例均使用mongoose进行操作数据库，以下不作说明) 12345678910111213141516171819const mongoose = require('mongoose'), User = mongoose.model('user');User.insertMany([&#123; "age": 18, "name": "user1", "sex": "female",&#125;, &#123; "age": 20, "name": "user2", "sex": "male",&#125;, &#123; "age": 22, "name": "user3", "sex": "female",&#125;, &#123; "age": 28, "name": "user4", "sex": "male",&#125;]) 然后使用聚合查询的match操作找出年龄在20岁以上(不包含20岁)的user 12345678910111213User.aggregate([&#123; $match: &#123; age: &#123; $gt: 20 &#125; &#125;&#125;]).exec((err, users) =&gt; &#123; if (err) &#123; // process error &#125; else &#123; // process users &#125;&#125;); 易错点在进行_id匹配时要使用ObhectId来进行匹配，而不是普通的字符串_id来匹配 错误示例：12345678User.aggregate([&#123; $match: &#123; _id: &#123;$in: ['592eb5c443d5c897d8282c88']&#125;, &#125;&#125;]).exec((err, user) =&gt; &#123; console.log(user.length);// 0&#125;); 正确示例12345678910const mongoose = require('mongoose'), User = mongoose.model('user');User.aggregate([&#123; $match: &#123; _id: &#123;$in: [mongoose.Types.ObjectId('592eb5c443d5c897d8282c88')]&#125;,// 注意，是这里做了修改 &#125;&#125;]).exec((err, user) =&gt; &#123; console.log(user.length);// 1&#125;); 相关文档及问题 官方文档 Matching by ObjectId When Using Raw Query or Aggregation Moongoose aggregate $match does not match id’s How to use aggregrate in mongodb to $match _id Enjoy IT]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mongodb</tag>
        <tag>mongoose</tag>
        <tag>聚合查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs环境变量介绍及设置]]></title>
    <url>%2F2017%2F03%2F19%2Fbackend%2Fnode-env%2F</url>
    <content type="text"><![CDATA[环境变量？环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，那么类似，我们的nodejs在程序运行时也可以去设置一些运行时的参数。例如文件的存储位置，在开发时我们一般会把一些上传的文件放在本地，production的文件上传地址放在第三方的云服务器上进行存储；数据库的地址，这个就好理解了，开发用开发的数据库，测试用测试的数据库，生产环境就用生产环境的数据库这样会避免production上存在开发或者测试过程中产生的一些坏数据或假数据。显而易见，这样做的好处就是把各种环境隔离开来，互相不会干扰在设置nodejs的环境变量时我们是把所需要的配置添加到process的env属性上，之后我们就能使用我们的配置了，类似于下面这样 使用第三方node包加载环境变量如果让你添加环境变量是不是感觉有点麻烦？别怕，我们有众多的第三方node包可以使用例如cross-env、dotenv，下面是我的一些dotenv的使用经验，供大家参考：dot env是一个零依赖的node包，能够把你的node环境变量从.env文件中加载到process.env上面，从而让你可以在程序的任何地方访问到你的环境变量。 第一步当然是安装依赖喽 1npm install dotenv --save 在项目的根目录下新建一个.env文件，当然你也可以把这个文件放在项目的其它文件夹下，不过在加载的时候需要稍微设置一下 .env文件在项目根目录下 1require(&apos;.env&apos;).load(); 在其它文件夹下 1require(&apos;dotenv&apos;).load(&#123;path: &apos;your/dir/.env&apos;&#125;); 然后再向你的.env文件里面添加环境变量，规则是变量名=变量值，一行设置一个环境变量 1TEST_VARIABLE=Hello, my test! 执行你的js引入dotenv的js代码 我使用了load方法来加载env，当然你也可以使用config方法，都是同样的效果，下面是dotenv的部分源码： 123module.exports.config = configmodule.exports.load = configmodule.exports.parse = parse 里面还暴露出来了一个parse方法，设置你的文件的编码格式的，就不细说了使用时需要注意的是它在解析你的env文件时会把任何变量值转换成字符串，如果你的变量值是null或者undefined，或者false，就不要设置变量值，让它空着就好 Enjoy IT!]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress安装及简单配置]]></title>
    <url>%2F2016%2F04%2F25%2Fother%2Fwordpress%2F</url>
    <content type="text"><![CDATA[windows 安装xampp,下载地址 根据提示安装vc9x86,vc9x64,vc11x86,vc11x64 安装JDK,下载在oracle官网上面一个jdk， 下载wordpress官网. 把wordpress压缩包解压到xampp安装目录下的htdoc文件夹下面 按照wordpress官网进行配置 配置完成之后就可以通过网页建立自己的wordpress站点了，打开xamapp，启动apache服务器，启动mysql服务 打开浏览器，地址栏输入localhost/wordpress ubuntu download xampp install xampp in unbutu,move the .run program to desktop and run next cmder 12chmod +x xampp.runsudo ./xampp.run download wordpress extract wordpress move extracted wordpress to opt/lampp/htdocs/ wordpress setting start up serverce 12cd /opt/lampp/htdocs/./ctlscript.sh open browser intpu localhost/wordpress ，enter Enjoy IT]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>博客</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
</search>
